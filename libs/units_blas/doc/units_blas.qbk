[/
 / Copyright (c) 2008 T. Zachary Laine
 /
 / Distributed under the Boost Software License, Version 1.0. (See accompanying
 / file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /]

[library Boost.UnitsBlas
    [quickbook 1.3]
    [authors [Laine, Zach]]
    [copyright 2008 T. Zachary Laine]
    [category template]
    [id units_blas]
    [dirname units_blas]
    [purpose
        Linear algebra library for matrices containing heterogeneous
        types, suitable for use with Boost.Units.
    ]
    [license
        Distributed under the Boost Software License, Version 1.0.
        (See accompanying file LICENSE_1_0.txt or copy at
        [@http://www.boost.org/LICENSE_1_0.txt])
    ]
]

[/ QuickBook Document version 1.3 ]

[/ Images ]

[def __note__                       [$images/note.png]]
[def __tip__                        [$images/tip.png]]
[def __important__                  [$images/important.png]]
[def __caution__                    [$images/caution.png]]
[def __warning__                    [$images/warning.png]]
[def __bad_determinant__            [$images/bad_determinant.png]]
[def __f_matrix__                   [$images/f_matrix.png]]
[def __f_matrix_units__             [$images/f_matrix_units.png]]
[def __f_times_x__                  [$images/f_times_x.png]]
[def __f_times_x_units__            [$images/f_times_x_units.png]]
[def __h_matrix__                   [$images/h_matrix.png]]
[def __h_matrix_units__             [$images/h_matrix_units.png]]
[def __k_matrix_units__             [$images/k_matrix_units.png]]
[def __meas_vector__                [$images/meas_vector.png]]
[def __meas_vector_units__          [$images/meas_vector_units.png]]
[def __p_matrix__                   [$images/p_matrix.png]]
[def __p_matrix_units__             [$images/p_matrix_units.png]]
[def __predict_equations__          [$images/predict_equations.png]]
[def __r_matrix__                   [$images/r_matrix.png]]
[def __r_matrix_units__             [$images/r_matrix_units.png]]
[def __state_vector__               [$images/state_vector.png]]
[def __state_vector_units__         [$images/state_vector_units.png]]
[def __update_equations__           [$images/update_equations.png]]


[/ Links ]

[def _matrix_                       [classref boost::units_blas::matrix `matrix<>`]]
[def _matrices_                     [classref boost::units_blas::matrix `matrix<>`s]]
[def _make_matrix_                  [classref boost::units_blas::make_matrix `make_matrix<>`]]
[def _uniform_matrix_               [classref boost::units_blas::uniform_matrix `uniform_matrix<>`]]
[def _vector_                       [classref boost::units_blas::vector `vector<>`]]
[def _transpose_vector_             [classref boost::units_blas::transpose_vector `transpose_vector<>`]]
[def _uniform_vector_               [classref boost::units_blas::uniform_vector `uniform_vector<>`]]
[def _uniform_transpose_vector_     [classref boost::units_blas::uniform_transpose_vector `uniform_transpose_vector<>`]]
[def _is_vector_                    [classref boost::units_blas::is_vector `is_vector<>`]]
[def _is_transpose_vector_          [classref boost::units_blas::is_transpose_vector `is_transpose_vector<>`]]
[def _slice__                       [funcref boost::units_blas::slice `slice`]]
[def _slice_                        [funcref boost::units_blas::slice `slice<>`]]
[def _transpose__                   [funcref boost::units_blas::transpose `transpose`]]
[def _transpose_                    [funcref boost::units_blas::transpose `transpose<>`]]
[def _element_prod__                [funcref boost::units_blas::element_prod `element_prod`]]
[def _element_prod_                 [funcref boost::units_blas::element_prod `element_prod<>`]]
[def _element_div__                 [funcref boost::units_blas::element_div `element_div`]]
[def _element_div_                  [funcref boost::units_blas::element_div `element_div<>`]]
[def _determinant__                 [funcref boost::units_blas::determinant `determinant`]]
[def _determinant_                  [funcref boost::units_blas::determinant `determinant<>`]]
[def _inverse__                     [funcref boost::units_blas::inverse `inverse`]]
[def _inverse_                      [funcref boost::units_blas::inverse `inverse<>`]]
[def _prod__                        [funcref boost::units_blas::prod `prod`]]
[def _prod_                         [funcref boost::units_blas::prod `prod<>`]]
[def _sum__                         [funcref boost::units_blas::sum `sum`]]
[def _sum_                          [funcref boost::units_blas::sum `sum<>`]]
[def _diff__                        [funcref boost::units_blas::diff `diff`]]
[def _diff_                         [funcref boost::units_blas::diff `diff<>`]]
[def _neg__                         [funcref boost::units_blas::neg `neg`]]
[def _neg_                          [funcref boost::units_blas::neg `neg<>`]]
[def _dot__                         [funcref boost::units_blas::dot `dot`]]
[def _dot_                          [funcref boost::units_blas::dot `dot<>`]]
[def _cross__                       [funcref boost::units_blas::cross `cross`]]
[def _cross_                        [funcref boost::units_blas::cross `cross<>`]]
[def _norm_1__                      [funcref boost::units_blas::norm_1 `norm_1`]]
[def _norm_1_                       [funcref boost::units_blas::norm_1 `norm_1<>`]]
[def _norm_2__                      [funcref boost::units_blas::norm_2 `norm_2`]]
[def _norm_2_                       [funcref boost::units_blas::norm_2 `norm_2<>`]]
[def _norm_inf__                    [funcref boost::units_blas::norm_inf `norm_inf`]]
[def _norm_inf_                     [funcref boost::units_blas::norm_inf `norm_inf<>`]]
[def _norm_inf_index__              [funcref boost::units_blas::norm_inf_index `norm_inf_index`]]
[def _norm_inf_index_               [funcref boost::units_blas::norm_inf_index `norm_inf_index<>`]]
[def _solve__                       [funcref boost::units_blas::solve `solve`]]
[def _solve_                        [funcref boost::units_blas::solve `solve<>`]]
[def _iterate_                      [funcref boost::units_blas::iterate `iterate<>()`]]
[def _print_                        [memberref boost::units_blas::matrix::print `print()`]]
[def _value_at_                     [classref boost::units_blas::result_of::value_at `result_of::value_at<>`]]
[def _quick_start_                  [link boost_unitsblas.manual.quick_start Quick Start]]
[def _tutorial_                     [link units_blas.manual.tutorial Tutorial]]
[def _value_                        `units::quantity<>::value()`]
[def _from_value_                   `units::quantity<>::from_value()`]
[def _fus_vec_                      `fusion::vector<>`]

[/ External Links ]

[def _mpl_                          [@http://boost.org/libs/mpl/doc/index.html MPL]]
[def _fusion_                       [@http://boost.org/libs/fusion/doc/index.html Fusion]]

[include intro.qbk]

[section:manual Manual]

[heading Conventions]

All matrix dimensions are given as ROWSxCOLUMNS, so a 1x3 matrix has 1 row and
3 columns.

Except where otherwise noted, it is assumed that all example code is preceded
by:

    #include <boost/unts_blas.hpp>
    
    using namespace boost;

[include quick_start.qbk]

[import ../example/tutorial.cpp]

[section:tutorial Tutorial]

[heading A Note About Header Organization]

The headers in UnitsBlas are fairly fine-grained.  See the Reference section
for the specific contents of the UnitsBlas headers.  Additionally, one can
`#include <boost/units_blas.hpp>` to get all the library's headers, or one can
`#include <boost/units_blas/result_of.hpp>` to get all the headers in the
`boost/units_blas/result_of` directory.

[heading Creating _matrices_]

Typically, you will make a _matrix_ by declaring it as indicated previously.
For example:

[default_matrix_decl]

However, in a generic programming context this may be inconvenient.  _matrix_
will accept any type sequence of same-sized type sequences.  The type sequences
can be any of those in the _mpl_ or _fusion_ libraries, or in fact any other
compatible sequence (including views on sequences).  To use
non-`fusion::vector<>`s, use the metafunction _make_matrix_:

[make_matrix_decl]

As a convenience, a few other metafunctions are also supplied.  To create a N
x M _matrix_ in which every element has the same type, use _uniform_matrix_:

[uniform_matrix_decl]

This is equivalent to:

[equiv_uniform_matrix_decl]

To create a "vector" _matrix_ from a single type sequence, use _vector_:

[vector_decl]

This is equivalent to:

[equiv_vector_decl]

To create a "transpose vector" _matrix_ from a single type sequence, use
_transpose_vector_:

[transpose_vector_decl]

This is equivalent to:

[equiv_transpose_vector_decl]

Of course, there are _uniform_vector_ and _uniform_transpose_vector_:

[uniform_vector_decls]

This is equivalent to:

[equiv_uniform_vector_decls]

[heading Vectors]

As mentioned previously, there are no vector types in UnitsBlas.  "Vectors"
are degenerate _matrices_ with a single column.  "Transpose vectors" are
degenerate _matrices_ with a single row.  Note the use of quotes around the
terms "vector" and "transpose vector".  I have made an effort to do so
throughout, to underscore the fact that these are not distinct types, but are
instead kinds of _matrices_.

That being said, "vectors" and "transpose vectors" are treated a bit
differently than "normal" _matrices_ (those with both dimensions greater than
1).  There are overloads for many of the UnitsBlas functions, including the
operator overloads, that are designed to work with "vectors" and "transpose
vectors" in particular ways.  The general rule is to make common operations
easy to write in a natural way.  For instance, consider two 2 x 2 _matrices_
`a` and `b`.  The expression `a * b` performs the matrix product of `a` and
`b`.  Now consider two 2 x 1 "vectors" `v1` and `v2`.  The expression `v1 *
v2` is ill-formed, if taken to mean matrix product, since `v1` has a different
number of columns as the rows in `v2`.  So instead, the expression `v1 * v2`
performs the vector dot product of the two "vectors".  This means users can
simply write `a * b` or `v1 * v2`, both of which are very close to standard
mathematical notation, without needing to explicitly specify which operation
should be performed.  Given a 1 x 2 "transpose vector" `tv`, the expressions
`v * tv` and `tv * v` both perform matrix products, since that operation is
well-defined for both pairs of operands.

See the _quick_start_ section for a comprehensive list of the operations
defined for "vectors" and "transpose vectors".

[note It is usually not allowed to mix "vectors" and "transpose vectors" in
the same operation.  `operator*` is a notable exception, since matrix product
applies to such pairs of operands.]

In operations which must distinguish between "vectors", "transpose vectors",
and "regular" _matrices_, there is an ambiguous case: the 1 x 1 _matrix_.
When 1 x 1 _matrices_ are used, they are treated as if they are "regular"
_matrices_ if at all possible, otherwise they are treated as if they are
"vectors".  For instance, for 1 x 1 _matrices_ `v1` and `v2`, `v1 * v2`
resolves to the matrix-product overload of `operator*`, not a "vector" dot
product or "transpose vector" dot product.  Also, `dot(v1, v2)` (which has no
"regular" _matrix_ overload) resolves to the "vector" overload of `dot<>()`,
not the "transpose vector" overload.

[heading Indexing And Iteration]

Indexing is done with compile-time constants.  There is no interface for using
variables as indices into _matrices_.  This necessitates the need to use
_iterate_ to loop over elements of a _matrix_.

[note Indices into _matrices_ are usually only checked when they reach the
static assertions in _value_at_.]

_iterate_ is a generic facility for unrolling loops.  See [headerref
boost/units_blas/operations.hpp] and [headerref
boost/units_blas/detail/iteration.hpp] for examples.

[note Each iteration of an _iterate_ loop will be forced inline, to the extent
this is possible with the platform and compiler, when `NDEBUG` is defined.]

[heading I/O]

There is support for very simple output of _matrices_.  There is no support
for input of them.  _matrix_ has an unimplemented member function _print_;
include [headerref boost/units_blas/io.hpp] for the implementation and an
overload of `operator<<` for `std::ostream &` and _matrix_.

[heading Common Errors]

There are three categories of errors you will encounter when working with
UnitsBlas.

[heading Static Assertion Failures]

`BOOST_STATIC_ASSERT()` and `BOOST_MPL_ASSERT()` are used liberally throughout
UnitsBlas.  All nonobvious static assertions should have a comment indicating
the most probable reason for the error.

[heading Overload Failure]

[@http://en.wikipedia.org/wiki/SFINAE SFINAE] is used to resolve overloaded
functions.  The predicates used in the `enable_if`/`disable_if` code rely
heavily on the size of the _matrices_ supplied to a function.  So when you see
an error that says "no matching function ..." or similar, it is often due to
inappropriate dimensions on the _matrix_ parameters to the function you are
trying to call.

[heading A Giant, Unreadable Mess]

Errors that are not in either of the previous two categories usually fall into
this one.  Such errors are most commonly due to inappropriate quantity types
being used in the _matrix_ parameters.  For instance, a _matrix_ with no
determinant may produce a large number of hard-to-read errors that boil down
to the inability to add intermediate types used to calculate the determinant.

cross product is only for pairs of 3x1 or 1x3 matrices; note that cross products
of vectors in a space S are in the space S^2

slicing matrices for fun and profit

note that when quantities are in use, an identity matrix may have nontrivial
element types.  For a uniform matrix U, an identity matrix for U will be
all-dimensionless, but for some arbitrary matrix M, it may not be.

slow-ass swap

LU-decomposability wrt mixed units, use of LU-decompose for determinant()s of
matrices larger than 3 rows, inverse(), and solve()

exceptions for singular matrices

[endsect]

[include example.qbk]

[include config.qbk]

[endsect]

[include adapting.qbk]

[section:rationale Rationale]

This is an overridable configuration macro controlling whether compile-time
assertions should be used to enforce that the boost::units_blas::matrix template
parameter \a Rows is a boost::fusion::vector of boost::fusion::vector's.  It is
turned off by default.  If this is not set, consider a matrix<A>, where A is
fusion vectors as stated before, and matrix<B>, where B is a boost::mpl::vector
of boost::mpl::vector's.  Both matrices will function exactly the same, and in
fact have the same \a value_types type, but are different types.  To prevent
accidental code bloat due to this effect, define this macro to a nonzero value
before including any library header.

uniform_matrix name selection (vs. homogeneous_matrix)

use of SFINAE in non-operator versions of operations, e.g. prod vs. operator* for consistency

rules for handling degenerate 1x1 amtrices (vector vs. transpose vector cases, and vector vs. matrix operator*)

use of operators, including the slightly wierd operator^ (note that cross products and bitwise xor have quite a bit in common)

[endsect]

[xinclude units_blas_reference.xml]
