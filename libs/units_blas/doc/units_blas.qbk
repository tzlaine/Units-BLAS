[/
 / Copyright (c) 2008 T. Zachary Laine
 /
 / Distributed under the Boost Software License, Version 1.0. (See accompanying
 / file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /]

[library Boost.UnitsBlas
    [quickbook 1.3]
    [authors [Laine, Zach]]
    [copyright 2008 T. Zachary Laine]
    [category template]
    [id units_blas]
    [dirname units_blas]
    [purpose
        Linear algebra library for matrices containing heterogeneous
        types, suitable for use with Boost.Units.
    ]
    [license
        Distributed under the Boost Software License, Version 1.0.
        (See accompanying file LICENSE_1_0.txt or copy at
        [@http://www.boost.org/LICENSE_1_0.txt])
    ]
]

[/ QuickBook Document version 1.3 ]

[/ Images ]

[def __note__               [$images/note.png]]
[def __tip__                [$images/tip.png]]
[def __important__          [$images/important.png]]
[def __caution__            [$images/caution.png]]
[def __warning__            [$images/warning.png]]
[def __bad_determinant__    [$images/bad_determinant.png]]
[def __f_matrix__           [$images/f_matrix.png]]
[def __f_matrix_units__     [$images/f_matrix_units.png]]
[def __f_times_x__          [$images/f_times_x.png]]
[def __f_times_x_units__    [$images/f_times_x_units.png]]
[def __h_matrix__           [$images/h_matrix.png]]
[def __h_matrix_units__     [$images/h_matrix_units.png]]
[def __k_matrix_units__     [$images/k_matrix_units.png]]
[def __meas_vector__        [$images/meas_vector.png]]
[def __meas_vector_units__  [$images/meas_vector_units.png]]
[def __p_matrix__           [$images/p_matrix.png]]
[def __p_matrix_units__     [$images/p_matrix_units.png]]
[def __predict_equations__  [$images/predict_equations.png]]
[def __r_matrix__           [$images/r_matrix.png]]
[def __r_matrix_units__     [$images/r_matrix_units.png]]
[def __state_vector__       [$images/state_vector.png]]
[def __state_vector_units__ [$images/state_vector_units.png]]
[def __update_equations__   [$images/update_equations.png]]

[/ Links ]

[def _matrix_               [classref boost::units_blas::matrix `matrix<>`]]
[def _fus_vec_              [classref boost::fusion::vector `fusion_vector<>`]]
[def _is_vector_            [classref boost::units_blas::is_vector `is_vector<>`]]
[def _is_transpose_vector_  [classref boost::units_blas::is_transpose_vector `is_transpose_vector<>`]]
[def _slice__               [funcref boost::units_blas::slice `slice`]]
[def _slice_                [funcref boost::units_blas::slice `slice<>`]]
[def _transpose__           [funcref boost::units_blas::transpose `transpose`]]
[def _transpose_            [funcref boost::units_blas::transpose `transpose<>`]]
[def _element_prod__        [funcref boost::units_blas::element_prod `element_prod`]]
[def _element_prod_         [funcref boost::units_blas::element_prod `element_prod<>`]]
[def _element_div__         [funcref boost::units_blas::element_div `element_div`]]
[def _element_div_          [funcref boost::units_blas::element_div `element_div<>`]]
[def _determinant__         [funcref boost::units_blas::determinant `determinant`]]
[def _determinant_          [funcref boost::units_blas::determinant `determinant<>`]]
[def _inverse__             [funcref boost::units_blas::inverse `inverse`]]
[def _inverse_              [funcref boost::units_blas::inverse `inverse<>`]]
[def _prod__                [funcref boost::units_blas::prod `prod`]]
[def _prod_                 [funcref boost::units_blas::prod `prod<>`]]
[def _sum__                 [funcref boost::units_blas::sum `sum`]]
[def _sum_                  [funcref boost::units_blas::sum `sum<>`]]
[def _diff__                [funcref boost::units_blas::diff `diff`]]
[def _diff_                 [funcref boost::units_blas::diff `diff<>`]]
[def _neg__                 [funcref boost::units_blas::neg `neg`]]
[def _neg_                  [funcref boost::units_blas::neg `neg<>`]]
[def _dot__                 [funcref boost::units_blas::dot `dot`]]
[def _dot_                  [funcref boost::units_blas::dot `dot<>`]]
[def _cross__               [funcref boost::units_blas::cross `cross`]]
[def _cross_                [funcref boost::units_blas::cross `cross<>`]]
[def _norm_1__              [funcref boost::units_blas::norm_1 `norm_1`]]
[def _norm_1_               [funcref boost::units_blas::norm_1 `norm_1<>`]]
[def _norm_2__              [funcref boost::units_blas::norm_2 `norm_2`]]
[def _norm_2_               [funcref boost::units_blas::norm_2 `norm_2<>`]]
[def _norm_inf__            [funcref boost::units_blas::norm_inf `norm_inf`]]
[def _norm_inf_             [funcref boost::units_blas::norm_inf `norm_inf<>`]]
[def _norm_inf_index__      [funcref boost::units_blas::norm_inf_index `norm_inf_index`]]
[def _norm_inf_index_       [funcref boost::units_blas::norm_inf_index `norm_inf_index<>`]]
[def _solve__               [funcref boost::units_blas::solve `solve`]]
[def _solve_                [funcref boost::units_blas::solve `solve<>`]]
[def _value_                `quantity::value()`]
[def _from_value_           `quantity::from_value()`]



[/ External Links ]

[def _mpl_                  [@http://boost.org/libs/mpl/doc/index.html MPL]]

[include intro.qbk]

[section:manual Manual]

[heading Conventions]

All matrix dimensions are given as ROWSxCOLUMNS, so a 1x3 matrix has 1 row and
3 columns.

Except where otherwise noted, it is assumed that all example code is preceded by:

    #include <boost/unts_blas.hpp>
    
    using namespace boost;

[include quick_start.qbk]

[section:tutorial Tutorial]

[heading A Note About Header Organization]

The headers in UnitsBlas are fairly fine-grained.  See the Reference section
for the specific contents of the UnitsBlas headers.  Additionally, one can
`#include <boost/units_blas.hpp>` to get all the library's headers, or one can
`#include <boost/units_blas/result_of.hpp>` to get all the headers in the
`boost/units_blas/result_of` directory.

make_matrix and friends

errors: SFINAE & no-such-overload errors == mismatched matrix dimensions,
whereas longer error messages means type error invloving individual elements;
also mention that indices are never checked, except in value_at<>

point out that indexing must always be done in compilte-time constants, never
variables, and that that necessitates the need to use iterate()

the iterate() facility, loop unrolling, and inlining

I/O

cross product is only for pairs of 3x1 or 1x3 matrices; note that cross products
of vectors in a space S are in space S^2

slicing matrices for fun and profit

rules for operators, especially wrt vectors/transpose-vectors

note that when quantities are in use, an identity matrix may have nontrivial
element types.  For a uniform matrix U, an identity matrix for U will be
all-dimensionless, but for some arbitrary matrix M, it may not be.

slow-ass swap

LU-decomposability wrt mixed units, use of LU-decompose for determinant()s of
matrices larger than 3 rows, inverse(), and solve()

exceptions for singular matrices

[endsect]

[section:case_study Case Study: A Kalman Tracker]

[@http://en.wikipedia.org/wiki/Kalman_filter Kalman filtering] is a means of
estimating the state of a dynamic system from noisy measurements.

I am going to briefly describe the operation of a Kalman filter used to track
entities moving in a plane.  The equations used are fairly simple, but their
large number and the large number of elements in the matrices used in the
equations introduce numerous opportunities to get unit conversions and
dimensional analysis wrong, if they must be done by hand.  It is therefore
problem that prompted the creation of this library.

At a high level, a Kalman filter takes a series of measurements at various
times, and produces an estimate of the "true" measurement at those times.  It
does this for some time `t1` by:

# predicting the Kalman state at time `t1` based on the dynamics of the process being filtered, and the previous state at time `t0`;
# updating the Kalman state using the predicted state and a measurement *z* taken at time `t0`.

The system being modelled in our Kalman tracker is an object with constant
velocity moving in a plane.  So, measurements *z* of this object are:

__meas_vector__ __meas_vector_units__

Note that we do not directly try to model the object's position.  Instead we
model the state of the dyamic system.  Because of this, the state we are
estimating also contains the derivatives of the *z*'s elements with respect to
time (represented with a dot), so the state *x* is:

__state_vector__ __state_vector_units__

We also need to represent the uncertainty in the estimated state with a
covariance matrix *P*.  Each element of *P* is the covariance of the two
elements of the the state *x* noted in the element's subscript.

__p_matrix__ __p_matrix_units__

Here are the equations for the Kalman tracker's prediction step:

__predict_equations__

[*Q] is a covariance matrix representing process noise.  It has the same units
as *P*.

[*F] is a bit more interesting, from a dimensional analysis point of view.
[*F] represents the system's dynamics.  In this case, we are estimating the
state of a constant velocity system.  Therefore we choose an *F* that updates
the position elements with the constant velocity times the time interval, and
leaves the velocity elements unchanged:

__f_matrix__,

which implies

__f_times_x__,

which is exactly what we want.

Note that due to its assignment to *x'*,

__f_times_x_units__

This implies what the the units of *F* must be.  This is our first nontrivial
result of using matrices containing quantity types (dimensionless quantities
are represented with the empty set symbol):

__f_matrix_units__

Many people who see this for the first time find it counterintuitive that the
zero-valued elements are neither uniformly dimensionless, nor uniformly
dimensional.  Moreover, I have yet to meet anyone who found the types in this
matrix as a whole obvious or intuitive.

Given the predicted state *x'* and predicted covariance matrix *P'* and a
measurement *z*, here are the equations for the update step:

__update_equations__

[*R] is a covariance matrix representing measurement noise.

__r_matrix__ __r_matrix_units__

[*H] is the observation model.  It maps state vectors to measurement vectors.
In our case, the matrix should simply pluck out the position elements of the
state, leaving the velocity elements behind.

__h_matrix__ __h_matrix_units__

Here is another nonobvious result.  As was the case with *F*, the 1-valued
elements are dimensionless.  This makes sense when you consider the fact that
1-valued elements are usually used to preserve values found in other matrices
when performing matrix products.  This implies that to preserve an element's
value /and its type/, one must multiply by 1-dimensionless.

There is deeper meaning associated with the *S* and *K* matrices, but for our
purposes, just think of them as being temporaries that are convenient to use
when performing the updates of *x* and *P*.  *S* has the same units as *R*.
*K*'s units are:

__k_matrix_units__

So, what has been the point of this whole excersize?  By now you should be
convinced that getting the dimensional analysis right when dealing with a
large number of matrices involving dimensional types requires quite a bit of
thought, and is error prone simply because the analysis must be done in so
many places.  The solution to these problems often is only to use a fixed set
of units throughout your code.  Thus conversions to and from raw `value_type`s
are trivial, and unit cenversions are never needed.  However, this requires
discipline, and if the discipline is ever dropped, the resulting errors can be
difficult to diagnose.

[endsect]

[include config.qbk]

[endsect]

[include adapting.qbk]

[section:rationale Rationale]

This is an overridable configuration macro controlling whether compile-time
assertions should be used to enforce that the boost::units_blas::matrix template
parameter \a Rows is a boost::fusion::vector of boost::fusion::vector's.  It is
turned off by default.  If this is not set, consider a matrix<A>, where A is
fusion vectors as stated before, and matrix<B>, where B is a boost::mpl::vector
of boost::mpl::vector's.  Both matrices will function exactly the same, and in
fact have the same \a value_types type, but are different types.  To prevent
accidental code bloat due to this effect, define this macro to a nonzero value
before including any library header.

uniform_matrix name selection (vs. homogeneous_matrix)

use of SFINAE in non-operator versions of operations, e.g. prod vs. operator* for consistency

rules for handling degenerate 1x1 amtrices (vector vs. transpose vector cases, and vector vs. matrix operator*)

use of operators, including the slightly wierd operator^ (note that cross products and bitwise xor have quite a bit in common)

[endsect]

[xinclude units_blas_reference.xml]
