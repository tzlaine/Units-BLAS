[/
 / Copyright (c) 2008 T. Zachary Laine
 /
 / Distributed under the Boost Software License, Version 1.0. (See accompanying
 / file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /]

[import ../example/quick_start.cpp]

[section:quick_start Quick Start]

[heading Matrices]

Matrices are declared in the form:

    units_blas::matrix<
        std::tuple< ... >,
        std::tuple< ... >,
        ...
    > my_matrix;

For example, assuming there exist three quantity types `length`, `time_`, and
`frequency`, these are all valid matrices:

[/ this does not seems to want to work, so I'm cut-and-pasting instead: quick_start_example_types]

    // a 1x3 matrix
    typedef units_blas::matrix<
        std::tuple<length, time_, frequency>
    > matrix_type_1;
    
    // a 3x1 matrix
    typedef units_blas::matrix<
        std::tuple<length>,
        std::tuple<time_>,
        std::tuple<frequency>
    > matrix_type_2;
    
    // a 2x2 matrix
    typedef units_blas::matrix<
        std::tuple<length, time_>,
        std::tuple<frequency, time_>
    > matrix_type_3;

[heading Operations On Matrices]

By default, UnitsBlas provides operator overloads where they make sense.  So, to
multiply two matrices `m1` and `m2`, write:

    m1 * m2

To multiply matrix `m` by a scalar `s`, write:

    m * s

or:

    s * m

Here is a summary of the operations on matrices.  In the table below, `M1` and
`M2` are _matrix_ objects, `s` is a scalar, `Rows` and `Columns` are
`std::index_sequence`s, and `e1` is an element of _matrix_ `M1`.

[table Matrix Operations
    [[Operation Syntax] [Description] [Notes]]
    [[`M1 += M2`]                      [ Elementwise addition. ]                          []]
    [[`M1 -= M2`]                      [ Elementwise subtraction. ]                       []]
    [[`M1 *= s`]                       [ Matrix-scalar product. ]                         [ Won't compile if `e1 = decltype(e1 * s)` doesn't compile. ]]
    [[`M1 /= s`]                       [ Matrix-scalar division. ]                        [ Won't compile if `e1 = decltype(e1 / s)` doesn't compile. ]]
    [[`-M1`

      _neg__`(M)`]              [ Elementwise negation. ]                          []]
    [[`M1 * M2`

      _prod__`(M1, M2)`]    [ Matrix-matrix product. ]                         []]
    [[`M1 * s`

      _prod__`(M1, s)`]      [ Matrix-scalar product. ]                         []]
    [[`s * M1`

      _prod__`(s, M2)`]      [ Matrix-scalar product. ]                         []]
    [[`M1 + M2`

      _sum__`(M1, M2)`]     [ Elementwise addition. ]                          []]
    [[`M1 - M2`

      _diff__`(M1, M2)`]    [ Elementwise subtraction. ]                       []]
    [[_element_prod__`(M1, M2)`]       [ Elementwise product. ]                           []]
    [[_element_div__`(M1, M2)`]        [ Elementwise division. ]                          []]
    [[_slice__`<Rows, Columns>(M1)`]   [ Construct new matrix from some set of rows and columns of original matrix. ] []]
    [[_transpose__`(M1)`]              [ Matrix transpose. ]                              []]
    [[_determinant__`(M1)`]            [ Matrix determinant. ]                            [ `M1` must be square. ]]
    [[_inverse__`(M1)`]                [ Matrix inverse. ]                                [ `M1` must be square.  Throws if `M1` is singular. ]]
]

[heading Vectors]

There are no vector types in UnitsBlas.  Vectors are merely degenerate matrices.
All the UnitsBlas vector operations accept _matrix_ parameters of the
appropriate dimensions (either 1 x N or N x 1).  Overloads are provided for both
orientations where approprate.

Here is a summary of the operations specific to "vectors".  Since "vectors"
are just matrices, all matrix operations also apply to "vectors".  In the
table below, `V1` and `V2` are Nx1 or 1xN _matrix_ objects.

[table Vector Operations
    [[Operation Syntax] [Description] [Notes]]
    [[`V1 * V2`

      _dot__`(V1, V2)`]     [ Dot product. ]                                       [ Elementwise products must be mutually summable. ]]
    [[`V1 ^ V2`

      _cross__`(V1, V2)`]   [ Cross product. ]                                     [ Vectors must be exactly 3x1 (or 1x3). ]]
    [[_sum__`(V1)`]                    [ Sum of all elements. ]                               [ Elements must be mutually summable. ]]
    [[_norm_1__`(V1)`]                 [ Sum of absolute values of all elements. ]            [ Elements must be mutually summable. ]]
    [[_norm_2__`(V1)`]                 [ Square root of sum of squares of all elements. ]     [ Elements must be mutually summable. ]]
    [[_norm_inf__`(V1)`]               [ Max of absolute values of all elements. ]            [ Elements must be pairwise less-than comparable. ]]
    [[_norm_inf_index__`(V1)`]         [ Index of first element equal to `norm_inf(V1)`. ]    [ Elements must be pairwise less-than comparable. ]]
    [[_solve__`(M1, V2, V1)`]          [ Solution to `M1 * V1 = V2` placed in `V1`. ]         [ `M1` must be square.  Throws if `M1` is singular. ]]
]

[endsect]
